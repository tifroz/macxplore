// Generated by CoffeeScript 1.10.0
window.CSVHead = React.createClass({displayName: "CSVHead",
  render: function() {
    var cols;
    console.log("Rendering head with ", this.props);
    return React.createElement("thead", null, (cols = this.props.data, React.createElement("tr", null, cols.map(function(v, i) {
      return React.createElement("th", {
        "key": i
      }, v);
    }))));
  }
});

window.CSVBody = React.createClass({displayName: "CSVBody",
  render: function() {
    console.log("Rendering body with ", this.props);
    return React.createElement("tbody", null, this.props.data.map(function(r, i) {
      return React.createElement(CSVRow, {
        "key": i,
        "data": r
      });
    }));
  }
});

window.CSVRow = React.createClass({displayName: "CSVRow",
  render: function() {
    var cols;
    cols = this.props.data;
    return React.createElement("tr", null, cols.map(function(v, i) {
      return React.createElement("td", {
        "key": i
      }, v);
    }));
  }
});

window.CSVTable = React.createClass({displayName: "CSVTable",
  render: function() {
    var head, rows;
    console.log("Rendering table with ", this.props);
    if (this.props.csv) {
      rows = xplore.util.csv2Array(this.props.csv, ",");
      if (rows.length > 0) {
        head = rows.shift();
        return React.createElement("table", {
          "className": "table-striped table-condensed table-responsive"
        }, React.createElement(CSVHead, {
          "key": "head",
          "data": head
        }), React.createElement(CSVBody, {
          "key": "body",
          "data": rows
        }));
      }
    } else {
      return null;
    }
  }
});

window.JsonViewer = React.createClass({displayName: "JsonViewer",
  componentDidMount: function() {
    var html;
    window.IsCollapsible = true;
    window.TAB = window.SINGLE_TAB;
    console.log("@props.doc", this.props.doc);
    html = ProcessObject(this.props.doc, 0, false, false, false);
    return $id("Canvas").innerHTML = "<PRE class='CodeContainer'>" + html + "</PRE>";
  },
  shouldComponentUpdate: function() {
    return true;
  },
  componentDidUpdate: function() {
    var html;
    html = ProcessObject(this.props.doc, 0, false, false, false);
    return $id("Canvas").innerHTML = "<PRE class='CodeContainer'>" + html + "</PRE>";
  },
  render: function() {
    return React.createElement("div", {
      "id": "Canvas"
    });
  }
});

window.PreviewSelector = React.createClass({displayName: "PreviewSelector",
  render: function() {
    return React.createElement("div", {
      "className": "btn-group",
      "data-toggle": "buttons"
    }, this.props.types.sort().map((function(_this) {
      return function(t, i) {
        var checked, className;
        checked = t === _this.props.type;
        className = "btn btn-primary btn-xs";
        if (checked) {
          className += " active";
        }
        return React.createElement("label", {
          "key": i,
          "className": className,
          "onClick": _this.selectionDidChange
        }, React.createElement("input", {
          "type": "radio",
          "name": "type",
          "autoComplete": "off",
          "value": t,
          "checked": checked,
          "onChange": (function() {})
        }), React.createElement("span", null, " ", t, " "));
      };
    })(this)));
  },
  selectionDidChange: function(e) {
    var input;
    input = $("input", e.currentTarget)[0];
    input.checked = true;
    return this.props.didChange(this.props.path, input.value);
  }
});

window.ReportPreview = React.createClass({displayName: "ReportPreview",
  mixins: [AjaxMixin],
  getInitialState: function() {
    var state;
    return state = {
      waiting: [],
      type: "sample doc",
      doc: null,
      csv: null,
      xhr: null,
      reportId: null,
      reportName: null
    };
  },
  componentDidMount: function() {
    $("body").on("didSelect", (function(_this) {
      return function(e) {
        console.log("didSelect", e);
        _this.setState({
          reportId: e.report._id
        });
        _this.setState({
          reportName: e.report.name
        });
        if (e.report.mode === "automatic") {
          return _this.fetch(e.report._id);
        } else {
          return _this.fetchSampleDoc(e.report._id);
        }
      };
    })(this));
    $("body").on("didUpdateQuery", (function(_this) {
      return function(e) {
        console.log("on didUpdateQuery", e);
        if (e.updateSample) {
          return _this.fetch(e.reportId);
        } else {
          return _this.fetchSampleDoc(e.reportId);
        }
      };
    })(this));
    $("body").on("didRequestSampleUpdated", (function(_this) {
      return function(e) {
        console.log("on didRequestSampleUpdated", e);
        if (e.updateSample) {
          if (_this.state.waiting.length > 0) {
            return alert("A query for sampled results is already in progress");
          } else {
            return _this.fetch(e.reportId);
          }
        }
      };
    })(this));
    return this.sizeMonitor = setInterval(this.monitorSize, 500);
  },
  componentWillUnmount: function() {
    return clearInterval(this.sizeMonitor);
  },
  render: function() {
    var activityClasses;
    return React.createElement("div", null, React.createElement(XHRError, {
      "xhr": this.state.xhr
    }), (this.state.doc || this.state.csv ? (activityClasses = "activity", this.state.waiting.length > 0 ? (console.log("Waiting for " + this.state.waiting), activityClasses += " on") : void 0, React.createElement("div", null, React.createElement(PreviewSelector, {
      "types": ["sample doc", "sample result"],
      "path": "type",
      "type": this.state.type,
      "didChange": this.didChange
    }), React.createElement("div", {
      "className": "ouputLinks"
    }, React.createElement("a", {
      "href": "/report/output/" + this.state.reportId + "/" + this.state.reportName + ".csv",
      "target": "_blank"
    }, "csv file")), React.createElement("div", {
      "className": activityClasses
    }, React.createElement("img", {
      "src": "http://getsetgames.com/wp-content/uploads/2009/12/ActivityIndicator.gif"
    })), (this.state.type === "sample doc" ? React.createElement(JsonViewer, {
      "doc": this.state.doc
    }) : this.state.type === "sample result" ? React.createElement(CSVTable, {
      "csv": this.state.csv
    }) : void 0))) : React.createElement("div", null)));
  },
  didChange: function(path, value) {
    console.log("ok Changed " + path + ", " + value);
    return this.setState({
      type: value
    });
  },
  monitorSize: function() {
    var e, h;
    if ((h = $("#preview").height()) !== this.height) {
      this.height = h;
      e = $.Event("previewPanelResized", {
        height: h
      });
      return $("body").trigger(e);
    }
  },
  fetch: function(reportId) {
    this.fetchSampleDoc(reportId);
    return this.fetchSampleOutput(reportId);
  },
  fetchSampleDoc: function(reportId) {
    var path;
    path = "/report/sampledoc/" + reportId;
    this.ajax(path, (function(_this) {
      return function(xhr, update) {
        var obj, obj1;
        _this.doneWithFetch(path);
        if (xhr.status > 0 && xhr.status < 400) {
          console.log("xhr.responseText", {
            doc: JSON.parse(xhr.responseText)
          });
          return _this.setState({
            doc: JSON.parse(xhr.responseText),
            xhr: (
              obj = {},
              obj["" + path] = xhr,
              obj
            )
          });
        } else {
          return _this.setState({
            xhr: (
              obj1 = {},
              obj1["" + path] = xhr,
              obj1
            )
          });
        }
      };
    })(this));
    return this.waitingForFetch([path]);
  },
  fetchSampleOutput: function(reportId) {
    var path;
    path = "/report/output/" + reportId + "/__sample.csv";
    this.ajax(path, (function(_this) {
      return function(xhr, update) {
        var obj, obj1;
        _this.doneWithFetch(path);
        if (xhr.status > 0 && xhr.status < 400) {
          return _this.setState({
            csv: xhr.responseText,
            xhr: (
              obj = {},
              obj["" + path] = xhr,
              obj
            )
          });
        } else {
          return _this.setState({
            xhr: (
              obj1 = {},
              obj1["" + path] = xhr,
              obj1
            )
          });
        }
      };
    })(this));
    return this.waitingForFetch([path]);
  },
  waitingForFetch: function(paths) {
    var waiting;
    waiting = this.state.waiting;
    waiting = waiting.concat(paths);
    return this.setState({
      waiting: waiting
    });
  },
  doneWithFetch: function(path) {
    var waiting;
    waiting = this.state.waiting;
    waiting = _.without(waiting, path);
    return this.setState({
      waiting: waiting
    });
  }
});

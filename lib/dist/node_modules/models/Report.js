// Generated by CoffeeScript 1.7.1
var MongoDoc, Report, Seq, coffee, events, logger, mr2FlatJson, streamify, util, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = require('underscore');

MongoDoc = require('macmodel');

events = require('events');

logger = require('maclogger');

Seq = require('seq');

coffee = require('coffee-script');

util = require('util');

streamify = require("stream-array");

mr2FlatJson = require("helpers").streams.mr2FlatJson;

Report = (function(_super) {
  __extends(Report, _super);

  function Report() {
    return Report.__super__.constructor.apply(this, arguments);
  }

  Report.prototype.init = function() {};

  Report.prototype.getTargetedCollection = function(fn) {
    var collection, colname, dbname, self, _ref;
    if (dbname = this._data.database && (colname = this._data.collection)) {
      if (collection = (_ref = MongoDoc.db.databases[dbname]) != null ? _ref.collections[colname] : void 0) {
        if (typeof fn === "function") {
          fn(null, collection);
        }
      }
    }
    if (this._data._id === void 0) {
      return typeof fn === "function" ? fn(new Error("Can't get collection without the report's _id")) : void 0;
    }
    dbname = null;
    colname = null;
    self = this;
    return Seq().seq(function() {
      logger.log("getTargetedCollection will fillFromStorage");
      return self.fillFromStorage(this);
    }).seq(function(r) {
      var data, report;
      logger.log("getTargetedCollection will linkDatabaseIfExists");
      data = r.data();
      dbname = data.database;
      colname = data.collection;
      report = r;
      return MongoDoc.db.linkDatabaseIfExists(dbname, this);
    }).seq(function() {
      var _ref1;
      logger.log("getTargetedCollection will return collection");
      if (collection = (_ref1 = MongoDoc.db.databases[dbname]) != null ? _ref1.collections[colname] : void 0) {
        return typeof fn === "function" ? fn(null, collection) : void 0;
      } else {
        return typeof fn === "function" ? fn(new Error("Database " + dbname + " could not be linked for " + colname + " (" + (_.keys(MongoDoc.db.databases[dbname].collections)) + ")")) : void 0;
      }
    })["catch"](function(boo) {
      return typeof fn === "function" ? fn(boo) : void 0;
    });
  };

  Report.prototype.getParsedParameters = function(qType) {
    var obj, recursiveParse, _ref, _ref1;
    if (qType === void 0) {
      qType = "all";
    }
    if (this._parsedParameters === void 0) {
      this._parsedParameters = {};
    }
    if (this._parsedParameters[qType]) {
      return this._parsedParameters[qType];
    } else if ((_ref = this._parsedParameters.all) != null ? _ref[qType] : void 0) {
      return (_ref1 = this._parsedParameters.all) != null ? _ref1[qType] : void 0;
    } else {
      recursiveParse = function(path, obj, result) {
        var cscript, err, jscript, key, p, separatorIndex, type, value, _results;
        _results = [];
        for (key in obj) {
          value = obj[key];
          if (path === null) {
            p = key;
          } else {
            p = "" + path + "." + key;
          }
          if (_.isString(value)) {
            separatorIndex = value.indexOf(":");
            type = value.substring(0, separatorIndex);
            cscript = value.substring(separatorIndex + 1).trim();
            if (cscript.length > 0) {
              try {
                jscript = coffee.compile(cscript, {
                  bare: true
                });
                logger.log("" + p + " jscript: " + jscript);
                eval("evaluated = " + jscript);
              } catch (_error) {
                err = _error;
                err.message = "Error compiling " + p + ": " + err.message;
                throw err;
              }
              if (evaluated !== void 0) {
                if (evaluated !== null) {
                  switch (type) {
                    case 'function':
                      if (!_.isFunction(evaluated)) {
                        throw new Error("Value for '" + p + "' must evaluate to a function");
                      }
                      break;
                    case 'number':
                      if (isNaN(evaluated)) {
                        throw new Error("Value for '" + p + "' must evaluate to a number");
                      }
                      break;
                    case 'string':
                      if (!_.isString(evaluated)) {
                        throw new Error("Value for '" + p + "' must evaluate to a string");
                      }
                  }
                }
                _results.push(result[key] = evaluated);
              } else {
                _results.push(void 0);
              }
            } else {
              _results.push(void 0);
            }
          } else {
            result[key] = {};
            _results.push(recursiveParse("" + p, value, result[key]));
          }
        }
        return _results;
      };
      this._parsedParameters = {};
      this._parsedParameters[qType] = {};
      if (qType === "all") {
        obj = this.data().parameters;
      } else {
        obj = this.data().parameters[qType];
      }
      if (!obj) {
        throw new Error("No inputs for parameters of type '" + qType + "'");
      }
      recursiveParse(null, obj, this._parsedParameters[qType]);
      return this._parsedParameters[qType];
    }
  };

  Report.prototype.getSampleCursor = function(fn) {
    var self;
    self = this;
    return Seq().seq(function() {
      return self.getTargetedCollection(this);
    }).seq(function(c) {
      var boo, cmd, cursor, options, params, qType, selector, _i, _len, _ref;
      qType = self.data().type;
      try {
        params = self.getParsedParameters(qType);
      } catch (_error) {
        boo = _error;
        return typeof fn === "function" ? fn(boo) : void 0;
      }
      selector = {};
      options = {
        sort: {
          _id: -1
        }
      };
      switch (qType) {
        case "find":
          selector = params.selector;
          _.extend(options, params.options);
          break;
        case "aggregate":
          _ref = params.pipeline;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            cmd = _ref[_i];
            if (cmd.$match) {
              selector = cmd.$match;
              break;
            }
          }
          break;
        case "group":
          selector = params.condition;
          break;
        case "count":
        case "distinct":
          selector = params.query;
          break;
        case "mapReduce":
          selector = params.options.query;
          break;
        default:
          return typeof fn === "function" ? fn(new Error("getCursor() can't be used with queries of type '" + qType + "'")) : void 0;
      }
      if (selector === void 0 || selector === null) {
        selector = {};
      }
      logger.log(util.format("SampleCursor with selector %j\nand options %j", selector, options));
      cursor = c.find(selector, options);
      return typeof fn === "function" ? fn(null, cursor) : void 0;
    })["catch"](function(boo) {
      return typeof fn === "function" ? fn(boo) : void 0;
    });
  };

  Report.prototype.getCursor = function(fn) {
    var self;
    self = this;
    return Seq().seq(function() {
      return self.getTargetedCollection(this);
    }).seq(function(c) {
      var boo, cursor, params, qType;
      qType = self.data().type;
      try {
        params = self.getParsedParameters(qType);
      } catch (_error) {
        boo = _error;
        return typeof fn === "function" ? fn(boo) : void 0;
      }
      switch (qType) {
        case "find":
          cursor = c.find(params.selector, params.options);
          return typeof fn === "function" ? fn(null, cursor) : void 0;
        case "aggregate":
          cursor = c.aggregate(params.pipeline, {
            cursor: {
              batchSize: 1
            }
          });
          return typeof fn === "function" ? fn(null, cursor) : void 0;
        default:
          return typeof fn === "function" ? fn(new Error("getCursor() can't be used with queries of type '" + qType + "'")) : void 0;
      }
    })["catch"](function(boo) {
      return typeof fn === "function" ? fn(boo) : void 0;
    });
  };

  Report.prototype.getStream = function(fn) {
    var self;
    self = this;
    return Seq().seq(function() {
      logger.log(util.format("Will get targeted collection"));
      return self.getTargetedCollection(this);
    }).seq(function(c) {
      var boo, params, qType;
      logger.log(util.format("OK have targeted collection"));
      qType = self.data().type;
      try {
        params = self.getParsedParameters(qType);
      } catch (_error) {
        boo = _error;
        return typeof fn === "function" ? fn(boo) : void 0;
      }
      switch (qType) {
        case "group":
          return c.group(params.keys, params.condition, params.initial, params.reduce, params.finalize, true, {}, function(err, list) {
            if (err) {
              return typeof fn === "function" ? fn(err) : void 0;
            } else {
              return typeof fn === "function" ? fn(null, streamify(list)) : void 0;
            }
          });
        case "mapReduce":
          logger.log(util.format("mapReduce with map " + params.map + ", reduce: " + params.reduce + ", options keys: " + (_.keys(params.options)) + ", options: %j", params.options));
          return c.mapReduce(params.map, params.reduce, params.options, function(err, list) {
            if (err) {
              return typeof fn === "function" ? fn(err) : void 0;
            } else {
              return typeof fn === "function" ? fn(null, streamify(list).pipe(mr2FlatJson())) : void 0;
            }
          });
        case "distinct":
          return c.distinct(params.key, params.query, function(err, list) {
            var json, makeKVJson, v;
            if (err) {
              return typeof fn === "function" ? fn(err) : void 0;
            } else {
              makeKVJson = function(key, value) {
                var kv;
                kv = {};
                kv[key] = value;
                return kv;
              };
              json = (function() {
                var _i, _len, _results;
                _results = [];
                for (_i = 0, _len = list.length; _i < _len; _i++) {
                  v = list[_i];
                  _results.push(makeKVJson(params.key, v));
                }
                return _results;
              })();
              return typeof fn === "function" ? fn(null, streamify(json)) : void 0;
            }
          });
        case "count":
          logger.log(util.format("count with query %j", params.query));
          return c.count(params.query, {}, function(err, count) {
            if (err) {
              return typeof fn === "function" ? fn(err) : void 0;
            } else {
              return typeof fn === "function" ? fn(null, streamify([
                {
                  count: count
                }
              ])) : void 0;
            }
          });
        default:
          return typeof fn === "function" ? fn(new Error("getReportData() can't be used with queries of type '" + qType + "'")) : void 0;
      }
    })["catch"](function(boo) {
      return typeof fn === "function" ? fn(boo) : void 0;
    });
  };

  return Report;

})(MongoDoc);

Report.makeDefaultReport = function(dbname, colname) {
  var data;
  data = {
    name: "New " + colname,
    database: dbname,
    collection: colname,
    comment: "(Enter comment here)",
    type: "find",
    mode: "manual",
    parameters: {
      find: {
        selector: "object:{}",
        options: {
          sort: "object:{}",
          fields: "object:{}"
        }
      },
      group: {
        keys: "object:{_id:1}",
        condition: "object:{}",
        initial: "object:{\n\ttotal: 0\n\tcount: 0\n} # The initial aggregation object (result)",
        reduce: "function:(curr, result)->\n\t#result.total += curr.item.qty\n\t#result.count += 1\n",
        finalize: "function:(result)->\n\t#e.g compute and add an average count to the result\n\t#return result\n"
      },
      mapReduce: {
        map: "function:()->\n\t#emit(this.key, this.value)\n",
        reduce: "function:(key, values)->\n\treturn 1",
        options: {
          query: "object:{}",
          sort: "object:{}",
          limit: "number:",
          out: "object:{inline: 1} # {replace:'collectionName'}, {merge:'collectionName'}, {reduce:'collectionName'}",
          finalize: "function:",
          scope: "object: {}"
        }
      },
      distinct: {
        key: "string:\"_id\"",
        query: "object:{}"
      },
      count: {
        query: "object:{}"
      },
      aggregate: {
        pipeline: "array:[]"
      }
    }
  };
  return new Report(data);
};

_.extend(Report, events.EventEmitter.prototype);

Report.setLogger(logger);

Report.collectionName = "report";

MongoDoc.register(Report);

module.exports = Report;

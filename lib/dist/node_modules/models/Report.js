// Generated by CoffeeScript 2.2.3
var MongoDoc, Report, Seq, _, coffee, events, logger, mr2FlatJson, streamify, util;

_ = require('underscore');

MongoDoc = require('macmodel');

events = require('events');

Seq = require('seq');

coffee = require('coffeescript');

util = require('util');

streamify = require("stream-array");

mr2FlatJson = require("helpers").streams.mr2FlatJson;

logger = console;

Report = class Report extends MongoDoc {
  init() {}

  //logger.info "OK initialized Report"
  getTargetedCollection(fn) {
    var collection, colname, dbname, ref, self;
    if (dbname = this._data.database && (colname = this._data.collection)) {
      if (collection = (ref = MongoDoc.db.databases[dbname]) != null ? ref.collections[colname] : void 0) {
        if (typeof fn === "function") {
          fn(null, collection);
        }
      }
    }
    if (this._data._id === void 0) {
      return typeof fn === "function" ? fn(new Error("Can't get collection without the report's _id")) : void 0;
    }
    dbname = null;
    colname = null;
    self = this;
    return Seq().seq(function() {
      logger.debug("getTargetedCollection will fillFromStorage");
      return self.fillFromStorage(this);
    }).seq(function(r) {
      var data, report;
      logger.debug("getTargetedCollection will linkDatabaseIfExists");
      data = r.data();
      dbname = data.database;
      colname = data.collection;
      report = r;
      return MongoDoc.db.linkDatabaseIfExists(dbname, this);
    }).seq(function() {
      var ref1;
      logger.debug("getTargetedCollection will return collection");
      if (collection = (ref1 = MongoDoc.db.databases[dbname]) != null ? ref1.collections[colname] : void 0) {
        return typeof fn === "function" ? fn(null, collection) : void 0;
      } else {
        return typeof fn === "function" ? fn(new Error(`Database ${dbname} could not be linked for ${colname} (${_.keys(MongoDoc.db.databases[dbname].collections)})`)) : void 0;
      }
    }).catch(function(boo) {
      return typeof fn === "function" ? fn(boo) : void 0;
    });
  }

  getParsedParameters(qType) {
    var obj, recursiveParse, ref, ref1;
    if (qType === void 0) {
      qType = "all";
    }
    if (this._parsedParameters === void 0) {
      this._parsedParameters = {};
    }
    if (this._parsedParameters[qType]) {
      return this._parsedParameters[qType];
    } else if ((ref = this._parsedParameters.all) != null ? ref[qType] : void 0) {
      return (ref1 = this._parsedParameters.all) != null ? ref1[qType] : void 0;
    } else {
      recursiveParse = function(path, obj, result) {
        var cscript, err, evaluated, jscript, key, p, results, separatorIndex, type, value;
        results = [];
        for (key in obj) {
          value = obj[key];
          if (path === null) {
            p = key;
          } else {
            p = `${path}.${key}`;
          }
          if (_.isString(value)) {
            separatorIndex = value.indexOf(":");
            type = value.substring(0, separatorIndex);
            cscript = value.substring(separatorIndex + 1).trim();
            if (cscript.length > 0) {
              try {
                jscript = coffee.compile(cscript, {
                  bare: true
                });
                logger.debug(`${p} jscript: ${jscript}`);
                evaluated = void 0;
                eval(`evaluated = ${jscript}`);
              } catch (error) {
                err = error;
                err.message = `Error compiling ${p}: ${err.message}`;
                throw err;
              }
              if (evaluated !== void 0) {
                if (evaluated !== null) {
                  switch (type) {
                    case 'function':
                      if (!_.isFunction(evaluated)) {
                        throw new Error(`Value for '${p}' must evaluate to a function`);
                      }
                      break;
                    case 'number':
                      if (isNaN(evaluated)) {
                        throw new Error(`Value for '${p}' must evaluate to a number`);
                      }
                      break;
                    case 'string':
                      if (!_.isString(evaluated)) {
                        throw new Error(`Value for '${p}' must evaluate to a string`);
                      }
                  }
                }
                results.push(result[key] = evaluated);
              } else {
                results.push(void 0);
              }
            } else {
              results.push(void 0);
            }
          } else {
            result[key] = {};
            results.push(recursiveParse(`${p}`, value, result[key]));
          }
        }
        return results;
      };
      this._parsedParameters = {};
      this._parsedParameters[qType] = {};
      if (qType === "all") {
        obj = this.data().parameters;
      } else {
        obj = this.data().parameters[qType];
      }
      if (!obj) {
        throw new Error(`No inputs for parameters of type '${qType}'`);
      }
      recursiveParse(null, obj, this._parsedParameters[qType]);
      return this._parsedParameters[qType];
    }
  }

  getSampleCursor(fn) {
    var self;
    self = this;
    return Seq().seq(function() {
      return self.getTargetedCollection(this);
    }).seq(function(c) {
      var boo, cmd, cursor, i, len, options, params, qType, ref, selector;
      qType = self.data().type;
      try {
        params = self.getParsedParameters(qType);
      } catch (error) {
        boo = error;
        return typeof fn === "function" ? fn(boo) : void 0;
      }
      selector = {};
      options = {
        sort: {
          _id: -1
        }
      };
      switch (qType) {
        case "find":
          selector = params.selector;
          _.extend(options, params.options);
          break;
        case "aggregate":
          ref = params.pipeline;
          for (i = 0, len = ref.length; i < len; i++) {
            cmd = ref[i];
            if (cmd.$match) {
              selector = cmd.$match;
              break;
            }
          }
          break;
        case "group":
          selector = params.condition;
          break;
        case "count":
        case "distinct":
          selector = params.query;
          break;
        case "mapReduce":
          selector = params.options.query;
          break;
        default:
          return typeof fn === "function" ? fn(new Error(`getCursor() can't be used with queries of type '${qType}'`)) : void 0;
      }
      if (selector === void 0 || selector === null) {
        selector = {};
      }
      logger.debug(util.format("SampleCursor with selector %j\nand options %j", selector, options));
      cursor = c.find(selector, options);
      return typeof fn === "function" ? fn(null, cursor) : void 0;
    }).catch(function(boo) {
      return typeof fn === "function" ? fn(boo) : void 0;
    });
  }

  getCursor(fn) {
    var self;
    self = this;
    return Seq().seq(function() {
      return self.getTargetedCollection(this);
    }).seq(function(c) {
      var boo, cursor, params, qType;
      qType = self.data().type;
      try {
        params = self.getParsedParameters(qType);
      } catch (error) {
        boo = error;
        return typeof fn === "function" ? fn(boo) : void 0;
      }
      switch (qType) {
        case "find":
          cursor = c.find(params.selector, params.options);
          return typeof fn === "function" ? fn(null, cursor) : void 0;
        case "aggregate":
          cursor = c.aggregate(params.pipeline, {
            cursor: {
              batchSize: 1
            }
          });
          return typeof fn === "function" ? fn(null, cursor) : void 0;
        default:
          return typeof fn === "function" ? fn(new Error(`getCursor() can't be used with queries of type '${qType}'`)) : void 0;
      }
    }).catch(function(boo) {
      return typeof fn === "function" ? fn(boo) : void 0;
    });
  }

  getStream(fn) {
    var self;
    self = this;
    return Seq().seq(function() {
      logger.debug(util.format("Will get targeted collection"));
      return self.getTargetedCollection(this);
    }).seq(function(c) {
      var boo, params, qType;
      logger.debug(util.format("OK have targeted collection"));
      qType = self.data().type;
      try {
        params = self.getParsedParameters(qType);
      } catch (error) {
        boo = error;
        return typeof fn === "function" ? fn(boo) : void 0;
      }
      switch (qType) {
        case "group":
          return c.group(params.keys, params.condition, params.initial, params.reduce, params.finalize, true, {}, function(err, list) {
            if (err) {
              return typeof fn === "function" ? fn(err) : void 0;
            } else {
              return typeof fn === "function" ? fn(null, streamify(list)) : void 0;
            }
          });
        case "mapReduce":
          logger.debug(util.format(`mapReduce with map ${params.map}, reduce: ${params.reduce}, options keys: ${_.keys(params.options)}, options: %j`, params.options));
          return c.mapReduce(params.map, params.reduce, params.options, function(err, list) {
            if (err) {
              return typeof fn === "function" ? fn(err) : void 0;
            } else {
              return typeof fn === "function" ? fn(null, streamify(list).pipe(mr2FlatJson())) : void 0;
            }
          });
        //c.mapReduce (->emit(this.locale,1)), (->return 1), {out: {inline: 1}}, fn
        case "distinct":
          return c.distinct(params.key, params.query, function(err, list) {
            var json, makeKVJson, v;
            if (err) {
              return typeof fn === "function" ? fn(err) : void 0;
            } else {
              makeKVJson = function(key, value) {
                var kv;
                kv = {};
                kv[key] = value;
                return kv;
              };
              json = (function() {
                var i, len, results;
                results = [];
                for (i = 0, len = list.length; i < len; i++) {
                  v = list[i];
                  results.push(makeKVJson(params.key, v));
                }
                return results;
              })();
              return typeof fn === "function" ? fn(null, streamify(json)) : void 0;
            }
          });
        case "count":
          logger.debug(util.format("count with query %j", params.query));
          return c.count(params.query, {}, function(err, count) {
            if (err) {
              return typeof fn === "function" ? fn(err) : void 0;
            } else {
              return typeof fn === "function" ? fn(null, streamify([
                {
                  count: count
                }
              ])) : void 0;
            }
          });
        default:
          return typeof fn === "function" ? fn(new Error(`getReportData() can't be used with queries of type '${qType}'`)) : void 0;
      }
    }).catch(function(boo) {
      return typeof fn === "function" ? fn(boo) : void 0;
    });
  }

};

Report.makeCopy = function(original) {
  var attributeName, data, i, len, og, ref;
  og = original.data();
  data = {
    name: `${og.name} copy`
  };
  ref = ["database", "collection", "comment", "type", "mode", "parameters"];
  for (i = 0, len = ref.length; i < len; i++) {
    attributeName = ref[i];
    data[attributeName] = og[attributeName];
  }
  return new Report(data);
};

Report.makeDefaultReport = function(dbname, colname) {
  var data;
  data = {
    name: `New ${colname}`,
    database: dbname,
    collection: colname,
    comment: "(Enter comment here)",
    type: "find",
    mode: "manual",
    tags: [dbname, colname],
    parameters: {
      find: {
        selector: "object:{}",
        options: {
          sort: "object:{}",
          fields: "object:{}"
        }
      },
      group: {
        keys: "object:{_id:1}",
        condition: "object:{}",
        initial: "object:{\n\ttotal: 0\n\tcount: 0\n} # The initial aggregation object (result)",
        reduce: "function:(curr, result)->\n\t#result.total += curr.item.qty\n\t#result.count += 1\n",
        finalize: "function:(result)->\n\t#e.g compute and add an average count to the result\n\t#return result\n"
      },
      mapReduce: {
        map: "function:()->\n\t#emit(this.key, this.value)\n",
        reduce: "function:(key, values)->\n\treturn 1",
        options: {
          query: "object:{}",
          sort: "object:{}",
          limit: "number:",
          out: "object:{inline: 1} # {replace:'collectionName'}, {merge:'collectionName'}, {reduce:'collectionName'}",
          finalize: "function:",
          scope: "object: {}"
        }
      },
      distinct: {
        key: "string:\"_id\"",
        query: "object:{}"
      },
      count: {
        query: "object:{}"
      },
      aggregate: {
        pipeline: "array:[]"
      }
    }
  };
  return new Report(data);
};

_.extend(Report, events.EventEmitter.prototype);

Report.setLogger(logger);

Report.collectionName = "report";

MongoDoc.register(Report);

module.exports = Report;

// Generated by CoffeeScript 2.2.3
var _, csvEscape, cursor2JsonArray, jsonToCsv, logger, mr2FlatJson, through, truncate, util, valueForKeyPath;

through = require('through');

_ = require('underscore');

logger = require('maclogger');

util = require('util');

valueForKeyPath = function(obj, keyPath) {
  var i, k, kp, len, value;
  kp = keyPath.split(".");
  value = obj;
  for (i = 0, len = kp.length; i < len; i++) {
    k = kp[i];
    value = value[k];
    if (!_.isObject(value)) {
      break;
    }
  }
  logger.log(`valueForKeyPath, for ${keyPath}=${value}`);
  return value;
};

csvEscape = function(any) {
  var keyPath, str;
  if (any === void 0 || any === null) {
    return any;
  } else {
    keyPath = any.toString().split(".");
    str = any.toString();
  }
  if (str.indexOf("\"") >= 0) {
    str.replace("\"", "\"\"");
  }
  if (str.indexOf(",") >= 0 || str.indexOf("\n") >= 0 || str.indexOf("\"") >= 0) {
    return `"${str}"`;
  } else {
    return str;
  }
};

cursor2JsonArray = function() {
  var end, first, stream, write;
  first = true;
  write = function(data) {
    logger.log(util.format("cursor2JsonArray data: %j", data));
    if (first) {
      first = false;
      this.queue("[\n");
    } else {
      this.queue(",\n");
    }
    return this.queue(util.format("%j", data));
  };
  end = function(data) {
    if (first) {
      this.queue("[]");
    } else {
      this.queue("\n]");
    }
    return this.queue(null);
  };
  stream = through(write, end);
  return stream;
};

// Will convert from {attr1: "value1", attr2: "value2", attr3: {sub1: "v1", sub2: "v2"}} to 

// attr1,		attr2,		attr3.sub1,		attr3.sub2
// value1, 	value2, 	v1,						v2
jsonToCsv = function() {
  var cols, end, first, stream, write;
  first = true;
  cols = [];
  write = function(data) {
    var i, index, key, obj, ref, row, subKeys, subkey;
    logger.log(util.format("jsonToCsv data: %j", data));
    if (first) {
      first = false;
      cols = _.keys(data);
      for (index = i = ref = cols.length - 1; (ref <= 0 ? i <= 0 : i >= 0); index = ref <= 0 ? ++i : --i) {
        key = cols[index];
        obj = data[key];
        logger.log(util.format(`For key ${key}, isObject ${_.isObject(obj)}, %j`, obj));
        if (_.isObject(obj)) { // and not _.isFunction obj and not _.isArray obj
          logger.log(`For key ${key}, sub-Keys ${_.keys(obj)}`);
          subKeys = (function() {
            var j, len, ref1, results;
            ref1 = _.keys(obj);
            results = [];
            for (j = 0, len = ref1.length; j < len; j++) {
              subkey = ref1[j];
              results.push(`${key}.${subkey}`);
            }
            return results;
          })();
          logger.log(`For key ${key}, subKeys ${subKeys}`);
          cols.splice(index, 1, subKeys);
        }
      }
      cols = _.flatten(cols);
      logger.log(`json2Csv columns: ${cols}`);
      this.queue(cols.join(",") + "\n");
    }
    row = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = cols.length; j < len; j++) {
        key = cols[j];
        results.push(csvEscape(valueForKeyPath(data, key)));
      }
      return results;
    })();
    return this.queue(row.join(",") + "\n");
  };
  end = function(data) {
    logger.log(util.format("jsonToCsv done"));
    return this.queue(null);
  };
  stream = through(write, end);
  return stream;
};

mr2FlatJson = function() {
  var end, first, stream, valueIsObject, write;
  first = true;
  valueIsObject = false;
  write = function(data) {
    var result;
    if (first) {
      first = false;
      valueIsObject = _.isObject(data.value);
    }
    if (valueIsObject) {
      result = {
        _id: data._id
      };
      _.extend(result, data.value);
      return this.queue(result);
    } else {
      return this.queue(data);
    }
  };
  end = function(data) {
    return this.queue(null);
  };
  stream = through(write, end);
  return stream;
};

truncate = function(max) {
  var count, end, stream, write;
  count = 0;
  write = function(data) {
    count++;
    if (count <= max) {
      return this.queue(data);
    }
  };
  end = function(data) {
    return this.queue(null);
  };
  stream = through(write, end);
  return stream;
};

module.exports = {
  json2Csv: jsonToCsv,
  mr2FlatJson: mr2FlatJson,
  cursor2JsonArray: cursor2JsonArray,
  truncate: truncate
};
